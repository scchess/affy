% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
% \VignetteIndexEntry{"affy"}
\documentclass[12pt]{article}

\usepackage{amsmath,pstricks}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\begin{document}
\title{Textual Description of affy}
\author{Rafael A. Irizarry and Laurent Gautier}
\maketitle
\tableofcontents
\section*{Introduction}
\verb+affy+ is part of the Bioconductor\footnote{http://www.bioconductor.org/} project. It is meant to be 
an extendible, interactive environment for data analysis
and exploration of Affymetrix oligonucleotide array probe level data. 

The software utilities provided with the Affymetrix suite summarizes
the probe set intensities to form one {\it  
expression measure} for each gene. As pointed out by
\cite{li:wong:2001a}, much can be learned
from studying the individual probe intensities, or as we call them,
the {\it probe level data}. This is why we developed this package.

We assume that the reader is already familiar with oligonucleotide 
arrays and with the design of the Affymetrix GeneChip arrays. If your not, we recommend the Appendix of the Affymetrix MAS manual \cite{affy}. The 
following terms are used throughout this document with a specific meaning.
\begin{description}
  \item[probe] oligonucleotides with length of 25 base pairs that are
  used to probe RNA targets.
  \item[perfect match ($PM$)] probe supposed to match perfectly the
  target sequence. 
  \item[mismatch ($MM$)] the probe supposed to have a base mismatch
  with the target sequence. 
  \item[probe pair] a unit composed of a  perfect
  match and its mismatch. 
  \item[affyID] an identification for a gene or a fraction of a gene
  on the array. 
  \item[probe pair set] several probes relating to a common affyID. 
\item[{\it CEL} files] contain measured intensities and locations for
an array that has been hybridized.
\item[{\it CDF} file] contain the information relating probe pair sets
to locations on the array are stored.
\end{description}

The package provides two approaches to working with probe level
data. The first is via probe level objects ({\it Plob}) and is intended 
for thenon-experent R user. One can 
automatically read in all the relevant information with one function
call and store it in a {\it Plob}. Various built in function permit the
user to easily view graphical displays of the data and compute expression
values. Section 1 demonstrates how to work with Plob. 
The second approach is more flexible and intended for users with some R
experience. This approach is better if you intend to do a lot of probe level
 analyses.
This approach uses objects of the classes {\it Cdf} and {\it
Cel} described through various examples in Section 2.  Section 3 gives some
details on how to extend and alter the package for your needs.

\section{Getting Started: Using Plobs}
The first thing you need to do is {\bf load the package}. 
\begin{Sinput}
R> library(affy) ##load the affy package
\end{Sinput}

This section described the use of Plobs (Probe level objects) 
through an example. This objects are easy to use. You can read
data, explore, and compute expression values with one function call for each. 
However, if you are going to be doing much probe
level analyses we recommend using the Cel/Cdf classes described in Section 3.

The Section 2.1 describes three lines of code that can get you started if all
you want is expression values. The rest of the Section demonstrate the
utility of the package via an example using the dilution experiment data set
described in \cite{iriz:etal:2002}.

\subsection{If you only want expression values}
If all you want is to get to convert probe level data into expression measures
a quick way of doing it is like this: Create a directory, move all your
{\it CEL} files and the appropriate {\it CDF} file to that directory. Start
R in that directory. Load the library and then type:

\begin{Sinput}
R> Data <-  ReadAffy() ##read data in working directory
R> e <- express(Data)
\end{Sinput}
Note there must be exactly one CDF file for this to work.

Now expression values are contained in \verb+e+ in the form of an
object of class \verb+exprSet+ (see Biobase). You can either use R
 and the bioconductor packages to analyze your expression data or if you 
rather use another package you can write it out to a tab delimeted file like
this

\begin{Sinput}
R> write.exprs(e,file="mydata.txt")
\end{Sinput}

This \verb+mydata.txt+ file will have genes in the rows and samples/arrays on 
the columns. The first row will be header describing the columns. The first 
column will have the affyIDs. However, you the \verb+write.exprs+ function is
quite flexible on what it writes (see help file).

\subsection{Loading Data into R}
As described in the previous section, the simplest way to this is by 
using the function \verb+ReadAffy+. The 
first step is to create a directory that contains all the {\it CEL} files
you want to read in and the appropriate {\it CDF} file. 

\begin{Sinput}
R> Dilution <- ReadAffy() ##read data and store it in Dilution
\end{Sinput}
\begin{Soutput}
reading CDF file
processing information
reading 9 CEL files..
preparing probe level object
\end{Soutput}

Note there must be exactly one CDF file for this to work. 

Alternatively the user can choose what files to be read using a
graphical display such as those shown in Figures \ref{f1} and
\ref{f2}. In order to 
do this, the widget argument must be true. 
\begin{Sinput}
R> Dilution <- ReadAffy(widget=T) 
\end{Sinput}

\begin{figure}[htbp]
\begin{center}
\includegraphics{widget1}
\caption{\label{f1}Graphical display for selecting {\it CDF} file.}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\includegraphics{widget2}
\caption{\label{f2}Graphical display for selecting {\it CEL} files.}
\end{center}
\end{figure}

The object created, and saved in \verb+Dilution+ will be a probe level
object (Plob). 

\subsection{Exploring Data}
For the users convenience we have included a sample data set
containing part of the data from a Dilution experiment. The full data
is publically available from Gene Locic 
\url{http://qolotus02.genelogic.com/datasets.nsf/} and desribed in \cite{iriz:etal:2002}. The help file obtained via \verb+?Dilution+ describes the data set.
Section 1.6 presents a case study using this Data.

<<echo=F,results=hide>>=
library(affy)
@

<<>>=
data(Dilution)
print(Dilution) ##this shows some important info
@ 

This will create a {\it Plob} called \verb+Dilution+ and \verb+print+
will shows some important information about it. These objects
are meant to represent data from one 
experiment. The {\it Plob} class combines the
information of various {\it Cel} files with a common {\it Cdf} file. This
class is designed to keep information of one experiment. It is
especially useful for users who want to obtain expression values
without much tinkering with {\it Cel} and {\it Cdf}. However, the probe
level data is available.

The data in \verb+Dilution+ is a small sample of 3 sets of triplicates
hybridized with different concentrations of the same RNA. 
This information is part of the Plob 

<<>>=
phenoData(Dilution)
pData(Dilution)
@ 

The main components of the Plob class can be accessed with the {\tt
pm}, {\tt mm}, and {\tt probeNames} methods. 
The components {\tt pm} and {\tt mm} are matrices with rows
representing probes pairs and columns representing arrays. The gene
name associated with the probe pair in row $i$ can be found in the
$i$th entry of {\tt name}. 

<<>>=
pm(Dilution)[1:5,]
mm(Dilution)[1:5,]
probeNames(Dilution)[1:5]
@ 

Other information about the experiment is
available in this class. See the {\it Plob} help file for details. 

The following useful methods  {\tt boxplot()}, {\tt hist()}, {\tt
history()}, {\tt image()},  {\tt profile()},  {\tt summary()}
are available for objects of this class.  
For example, Figure \ref{f3} shows histograms of $PM$ (red) and $MM$ (blue)
for the 3rd array obtained using {\tt hist()}. 

\begin{figure}[htbp]
\begin{center}
<<fig=TRUE>>=
hist(Dilution[,3]) ##histogram of PM and MM for 3rd array
@     
\caption{\label{f3} Histogram of $PM$ (red) and $MM$ (blue) of third array}
\end{center}
\end{figure}

\subsection{Normaliztion}
Various researchers have pointed out the need for normalization of Affymetrix
arrays \cite{bols:etal:2002}. Let's look at an  example.
The first three arrays in \verb+Dilution+ are technical replicates (same RNA),
so the intesities obtained from these should be about the same. 
Using the \verb+boxplot+ method for Plobs, shown in Figure \ref{f4}
we can see if this is the case.


\begin{figure}[htbp]
\begin{center}
<<fig=TRUE>>=
par(mfrow=c(2,1),mar=c(2,4,2,2))
boxplot(Dilution[,1:3],range=0)
@
\caption{\label{f4}Boxplot of first three arrays in dilution data.}
  \end{center}
\end{figure}

Figure \ref{f4} shows the need for normalization. For example the first array
is globally larger than the second.

Another way to see that normalization is need is by looking at log ratio 
versus average log intensity (MVA) plots. The function \verb+mva.pairs+ will
show all MVA plots of each pairwise comparison on the top right half and 
the interquartile range (IQR) of the log ratios on the bottom left half. 
For replicates and cases where most genes are not differentially expressed, 
we want the cloud of points to be around 0 and the IQR to be small.


\begin{figure}[htbp]
\begin{center}
<<echo=F>>=
options(warn=-1) 
@
<<fig=TRUE>>=
mva.pairs(Dilution[,1:3])
@     
\caption{\label{f5}MVA pairs for first three arrays in dilution Data}
  \end{center}
\end{figure}

The method \verb+normalize+ lets one normalize the data. 
<<>>=
normalized.Dilution <- normalize(Dilution[,1:3])
@
Various methods are availbale for normalization (see the help file). The 
default is quantile normalization \cite{bols:etal:2002}. 

Fiugure (\ref{f4.2} and (\ref{5.2}) show the boxplot and mva pairs plot after 
normalization.

\begin{figure}[htbp]
\begin{center}
<<fig=TRUE>>=
par(mfrow=c(2,1),mar=c(2,4,2,2))
boxplot(normalized.Dilution,range=0)
@
\caption{\label{f4.2}Boxplot of first three arrays in normalized 
dilution data.}
  \end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
<<echo=F>>=
options(warn=-1)
@
<<fig=TRUE>>=
mva.pairs(normalized.Dilution[,1:3])
@     
\caption{\label{f5.2}MVA pairs for first three arrays in normalized 
dilution Data}
  \end{center}
\end{figure}

\subsection{Expression Measures}
To perform gene expression analyses we need to summarize the probe set
data available for each gene into one expression measure. Various
approaches on how to do this have been proposed, see for example
\cite{affy}, \cite{li:wong:2001a}, and \cite{iriz:etal:2002}. Our
package permits the user to construct expression measures using any of
the approaches mentioned. The function \verb+express+ 
<<>>=
e <- express(Dilution)
@
returns expression measures in an object of class ExprSet 
(defined in the Biobase package). The {\tt exprs} slot of this class is
a matrix with rows  representing genesand columns representing arrays. 
Various bioconductor packages can be used to explore and analyze expression 
data. The 
\verb+write.exprs+ method is available to write expression tables to a file 
for users who which to use other packages.

An expression measure for a gene ca be considered a summary of the 
background corrected and normalized 
$PM$s of the probe set representing that gene.
The default for \verb+express+ is to use the approach presented
in \cite{iriz:etal:2002} (which is a log scale measure).
However, the function is quite flexible. 
The normalization method can be change through the 
\verb+normalize.method+ argumnet. Arbitrary functions 
can be passed along via the \verb+bg+ and \verb+summary.stat+ arguments 
for background correction and to summarize the 20 $PM$s into one number. 
Some background correction amd summary functions are provided with the 
package but the user can add their own. The help file contains more 
details. The next section presents a case study related to comparing 
expression measures.

\subsection{Case Study}
Two sources of cRNA A (human liver tissue) and B (Central Nervous
System cell line) have been hybridized to human array (HGU95A) in
a range of proportions and dilutions. The Diltion data provided with 
this package is taken from arrays hybridized to source A starting with
 2.5 $\mu$g cRNA, and
rising through 5.0, 10.0 $\mu$g. We have three replicate arrays for
each generated cRNA. Three scanners have been used in this study.
Each array replicate was  processed in a different scanner.

This dilution data
set is a great resource for assessing the technology becuse we know
that measures of expression for genes that are expressed showed grow
directly proportional to the amount of RNA hybridized (which is known) and
that replicates should be like each other.

As seen in Section ???, this data needs normalization. However, in this
case we can only normalize with replicates. Normalizing across replicates
is not recommended because the assumption needed for most normalization 
procedures (most genes, or at least a large group of genes, don't change much).
We therefore normalize the replicates and then use the \verb+union+ method
to put them together.

<<>>=
tmp1 <- normalize(Dilution[,1:3])
tmp2 <- normalize(Dilution[,4:6])
tmp3 <- normalize(Dilution[,7:9])

normalized.Dilution <- union(tmp1,tmp2)
normalized.Dilution <- union(normalized.Dilution,tmp3)
@ 

We are now ready to compute measures of expression. Keep in mind that
the \verb+express+ function normalizes by default, so we need to avoid this 
using the \verb+normalize+ argument.

<<results=hide>>=
e <- express(normalized.Dilution,normalize=F)
f <- express(Dilution,normalize=F)
@

To see if normalizing makes a difference, let's look at to 
expression for two randomley selected genes for the 9 arrays plotted against
known concentration. If the gene is expressed these values should be growing
with concentration but the replicates should be close if not equal. Figure
\ref{f6} shows the advantages of normaliztion: we still capture the signal
and reduce the variance.

\begin{figure}[htbp]
\begin{center}
<<fig=TRUE>>=
concentration <- pData(Dilution)[,1]
par(mfrow=c(2,2)) ##plot expressions for 2 random genes
for(j in 1:2){
  i <- sample(ngenes(Dilution),1)
  
  expr.with.norm<- 2^exprs(e)[i,]##measure is in the log scale
  expr.without.norm <- 2^exprs(f)[i,] 
 
  YLIM <- range(c(expr.with.norm,expr.without.norm))
  MAIN <- rownames(exprs(e))[j]

  plot(concentration,expr.with.norm,log="xy",main=MAIN,ylim=YLIM,xaxt="n")
  axis(1,concentration)

  plot(concentration,expr.without.norm,log="xy",main=MAIN,ylim=YLIM,xaxt="n")
  axis(1,concentration)
}
@ 
\caption{\label{f6}Comparison of expression measures obtained with and without normalization.}
  \end{center}
\end{figure}

Now let's assess the variance of 4 different measures of expression.

<<results=hide>>=
Dilution <- Dilution[,1:3] ##lets make it go faster
e <- express(Dilution) ##the default
##reduced model for li and wong you can get using:
LiWong <- express(Dilution, bg=subtractmm, summary.stat=li.wong)
##to get AvDiff: background correct by subtracting mm
##and the predifined avdiff function
Avdiff<-express(Dilution,normalize=F,bg=subtractmm,summary.stat=avdiff)
##which is pretty similar to
Avdiff2<-express(Dilution,normalize=F,bg=subtractmm,summary.stat=function(x) apply(x,2,mean,trim=.5))

##which has higher correlation between reps
assess <- function(w){
	x <- exprs(w)[,1]
        y <- exprs(w)[,2] 
	z <- exprs(w)[,3]        
        Index <- x>0 & y>0 
        signif(c(IQR(log2(x[Index]/y[Index]),na.rm=T),
		       IQR(log2(x[Index]/z[Index]),na.rm=T),
		       IQR(log2(y[Index]/z[Index]),na.rm=T)),2)
        }
@      
<<>>=
e@exprs <- 2^exprs(e) ##remember this is a log scale measure
##Let's look at IQR's for the 3 comparisons between replicates
assess(e) ##the defauls
assess(LiWong)
assess(Avdiff)
assess(Avdiff2)
@

Notice the default measure has the smallest IQR between replicates. See \cite{iriz:etal:2002} for assessments such as the one presented in this Section.

\section{Cdf/Cel Classes (and other classes)}

%This part of the documentation probably concerns more advanced users.

%Objects can be used to model actors of a process, and let one interact with it an reasonably intuitive way.
%The package benefited from important efforts in this sense. We hope we made it quickly usable and extendable.

%The relatively new system of classes in R (called the {\it S4 system}) was widely used in the package. The next few lines
%will introduce a limited number of elements relative to it. It should be able to enable users to whom the S4 system is not
%known to proceed through this document. More advanced knowledge of the system will probably needed for an advanced use.
%An instance of a class is a object materializing the description contained in the class definition.
%In other terms, the class defintion describes a model, and an instance of a class is an XXX. 
%For an instance \verb+a+ of a class \verb+MyClass+ having a attribute called \verb+myAttribute+, one can access the
%attribute simply by writing \verb+a@myAttribute+.
%In the R terminology 
%For the most common attributes, accessor methods are built in the class. Using the previous example, we would have an accessor
%function \verb+myAttribute+ applied to the instance \verb+a+: \verb+myAttribute(a)+ .

%Different classes have been implemented in the package to ease the manipulation of the data. The main ones are described below,
%with a note for their main \verb+slots+ and \verb+methods+.
%Users who are already familiar with the different categories of files involved in the analysis will not be surprised to find
%classes corresponding to the \verb+Cdf+ and \verb+Cel+ files.

The classes \verb+Cdf+ and \verb+Cel+ model the physical files in which data are stored. This can be useful for particular
operations. As stated in the introduction there is an alternative way of manipulating the data, which allows manipulation
of the data at a lower level.
The complete processing of the data presented in the previous section could be done using these objects.
It means more freedom, but it also means more complexity, and the need to
know the steps of the analysis leading from the probes data on different arrays and in different files to the expression values,
in an \verb+exprSet+.
However, this section should not be considered for advanced users only\footnote{Advanced users will not find enough details in the following this section and are recommended to read the help files}. While you may want to rely on the steps and methods
carefully crafted in the function \verb+express+, we also encourage you to observe the raw data contained in the {\it CEL} files.
It might be informative about problems that occured during the experimental steps leading to the data. 

For several attributes of the \verb+Cdf+ and \verb+Cel+ objects, it was decided to use matrices to store the data.
The lookup of values at particular positions on the chip becomes extremely easy (see figure~\ref{fig:gridcel}). 
\begin{figure}[h]
   \label{fig:gridcel}
   \begin{center}
     \includegraphics[scale=.6,angle=0]{gridcel}
   \end{center}
   \caption{The data matrix used to store the data can be thought of as a grid. Knowing the position of probes on the grid, finding the values
for them is done by indexing the corresponding elements.}
\end{figure}

The information is extracted from the combination of the \verb+Cel+ and the corresponding \verb+Cdf+.
Objects of class \verb+Plob+ (see~\ref{subsection:Plob}, page~\pageref{subsection:Plob}) have a different
data structure but also take their informations from a \verb+Cdf+ and \verb+Cel+ objects. A convenience function to shuttle between the data structures is included in the package (try \verb+help(convert)+ in R). 

While focusing on \verb+Cdf+ and \verb+Cel+, the section presents briefly other classes defined in the package. 

  \subsection{Cdf-class}

The {\it Chip Definition Files} ({\it CDF} files) are used to store informations related to
a type of oligonucleotide array sold by the manufacturer. All the arrays belonging to a given type will share this same information.
As the quantity of informations in a {\it CDF} can be rather large, this is an important point. This is kept in the design of the package,
as there will be only one \verb+Cdf+ object in memory, to which will refer the corresponding \verb+Cel+ files.

For instance when during an experiment a total of 30 arrays of type {\it Hu6800} are used, the information relative the array type is
common to all the chips. Knowing that a {\it CDF} files weights 20 Megabytes, will help to realize the interest of avoiding to repeat this information.


\begin{description}
 \item[name] Each {\it probe} (or {\it feature}) on an array is an oligonucleotide from a larger sequence of nucleic acids 
(generally a gene or a fraction of a gene), we refer to as a probe pairs set (XXX see PPSet).
 All these {\it large sequences} were given a unique name by the chip manufacturer. By design of the arrays severals probes correspond to different
parts of the same larger sequence, hence have the same name. Names are stored as factors, and the corresponding factors labels (or levels) are found in the
attribute \verb+name.levels+.
 \item[name.level]
 \item[pbase] In the {\it CDF} files, the column called {\it PBASE} holds one of the nucleic acid letters. From trials and errors
\footnote{Comparing the letter between {\it PBASE} and {\it TBASE}, it appeared that two cases could appear. }
, the {\it p} was guessed
 to stand for {\it probe}.
 \item[pbase.levels] The four levels for \verb+pbase+ are the four letters used to designatee nucleic acids.
 \item[tbase] In the {\it CDF} files, the column called {\it TBASE} holds also a nucleic acid letter. From trials and errors where the {\it t}
 was assumed to stand for {\it tbase}.
 \item[tbase.levels] The four same letters than for \verb+pbase.levels+ are found here.
 \item[atoms] Each {\it probe pair} in a {\it probe pair set} is given a unique integer as an indentifier.
This number is refered as the {\it atom} number. The corresponding {\it perfect matches} and {\it mismatches} are found by using this number.
\end{description}

In the following example, we look for the locations where a particular {\it affyID} is found on the chip.
Then we plot them over over a grid.
<<fig=TRUE>>=
data(CDF.example)
cdf <- CDF.example # to make the expression below clearer

affyid <- "D13640_at"

l.pm <- locate.name(affyid, cdf, type="pm")
l.mm <- locate.name(affyid, cdf, type="mm")

## plot a grid corresponding to CDF.example
n.y <- ncol(probeNames(cdf))
n.x <- nrow(probeNames(cdf))
plot(c(1,n.x), c(1,n.y), xlab="rows", ylab="columns", type="n")
grid(n.x, n.y)

## plot the locations
points(l.pm, col="red")
points(l.mm, col="blue")
@ 

%>>>LG: removed from the previous R statements
%Example:
%\vignette{Cdf-class}
%<<R.hide, echo=FALSE>>=
%  library(affy)
%@
%<<>>=
%  data(CDF.example)
%
%  affyid <- "D13640_at"
%  ## look for the position of the factor label "D13640_at"
%
%  i <- match(affyid, CDF.example@name.levels)
%  ## (it holds the integer value 43)
%  ## look for the corresponding name(s)
%  genepos <- which(CDF.example@name == i, arr.ind=TRUE)
%  ## genepos holds the x,y's corresponding to "D13640_at"
%  ## the function locate.name() is working this way.
%\end{verbatim}

%Example:
%\vignette{Cdf-class}
%<<>>= 
%  data(CDF.example)
%
%  ## store in x the size of the probe pair sets
%  ## (there are two atoms per pair, so we divide per 2)
%  x <- tapply(CDF.example@atom, CDF.example@name, FUN=length) / 2
%  dimnames(x) <- list(CDF.example@name.levels[as.integer(names(x))])
%  
%  ## select the probe pairs with less than 5 probe pairs
%  s <- which(x < 5)
%  
%  x[s]
%  
%  ## note: these probe pair sets mostly exist because example.CDF
%  ## is an artificial data set.
%  ## (which is a corner of a Hu6800 chip).
%@
%\end{verbatim}

\subsection{class Cel}

Objects of class \verb+Cel+ contain the informations held in {\it CEL} files.

\begin{description}
  \item[image] Display an {\it image} of the data in the \verb+Cel+ object. Among the other parameters, \verb+transfo=log+ can be convenient.
  \item[show] Outputs few general facts about the object on the console.
\end{description}

\subsection{class Cel.container}

The class \verb+Cel.container+ extends the class \verb+container+ of the package {\it Biobase}. It allows to bundle a collection of \verb+Cel+ instances
together. Typically, a \verb+Cel.container+ will contain \verb+Cel+ instances sharing the same \verb+Cdf+
% \footnote{We plan to have
%a link to the \verb+Cdf+ included in \verb+Cel.container+... probably in the next version...}.

\begin{description}
  \item[generateExprSet] Compute expression values and return them in an \verb+exprSet+ object.
  \item[normalize] A \verb+Cel.container+ can be {\it normalized}, which means its \verb+Cel+ elements will be scaled to be comparable. More details about normalization can be found in the section~\ref{sec:normalize}, page~\pageref{sec:normalize}.
  \item[normalize.methods] Return the known normalization methods for the \verb+Cel+.
  \item[show] Display global information about the object
\end{description}

\subsection{class PPSet}

\begin{description}
  \item[probes] a data frame having two column named {\it pm} and {\it mm} respectively. 
  \item[name] the name of the probe pair set
\end{description}

\begin{description}
  \item[show] Outputs few general facts about the object on the console.
  \item[barplot] Display a \verb+barplot+ of the probes informations
  \item[plot] Plot the probes informations in a lines graph.
\end{description}


\subsection{class PPSet.container}

\begin{description}
  \item[show] Outputs few general facts about the object on the console.
\end{description}

\subsection{class Plob}

The class \verb+Plob+ has been introduced in the previous section. One could think of it as related to the class \verb+Cel.container+
as it contains most of the information contained in it. It also contains informations from the corresponding CDF file. The data
are organised in a different structure. We think of it as an another view on the data.

%>>>LG: RAFA: HELP for below!!!

\begin{description}
  \item[normalize] A \verb+Plob+ can be {\it normalized}, which means the data coming from different the arrays
 will be scaled to be comparable. More details about normalization can be found in the section~\ref{sec:normalize}, page~\pageref{sec:normalize}.
  \item[normalize.methods] Return the known normalization methods for the \verb+Cel+.
  \item[plot] Displays plots.
  \item[show] Display global information about the object.
\end{description}

\section{Extending the package}
 \subsection{Normalization}

Different approaches to normalize array data have already been suggested, but new methods are very likely be developped too.
 We tried to make the addition of new normalization methods straightforward.
It should be the case if the following indications are carefully observed.
Brave people may want to add new normalization methods without taking these rules into considerations. It should be possible, but they are on their own.
\begin{itemize}
 \item[-] Normalization method must obey a naming convention. The name of the function should be like \verb+normalize.XYZ.abc+,
where \verb+abc+ is the {\it nickname} of the method and \verb+XYZ+ is the name of the object the normalization methods works on.
Currently XYZ can only be \verb+Cel.container+ or \verb+Plob+\footnote{A general scheme for normalization of arrays, whether
{\it Affymetrix} or cDNA (or even others in the future (?)) is currently evaluated.}. You are free to implement a normalization
 method working on one object without having to implement it for the others.
 \item[-] The first argument passed to the function must be of class \verb+XYZ+. Optional parameter can be appended as long
as they have default values./
 \item[-] The {\it nickname} of the new normalization method must be registered in the variable \verb+normalize.XYZ.methods+
 (a vector of mode {\it character}).
\end{itemize}

The following example shows how to create a normalization methods for \verb+Cel.container+
that does... absolutely nothing:

%\begin{vignette}
<<>>=
normalize.Cel.container.nothing <- function(object) return(object)
normalize.Cel.container.methods <- c(normalize.Cel.container.methods, "nothing")

data(listcel)

listcel.n <- normalize(listcel, method="nothing")
@

\bibliographystyle{plainnat} 
\bibliography{affy} 

\end{document}
